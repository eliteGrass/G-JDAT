# 代理模式（Proxy Pattern）完整讲解

## 目录
1. [什么是代理模式](#什么是代理模式)
2. [代理模式的分类](#代理模式的分类)
3. [后端代理模式实战](#后端代理模式实战)
4. [前端代理模式应用](#前端代理模式应用)
5. [总结与对比](#总结与对比)

---

## 什么是代理模式

### 定义
代理模式是一种结构型设计模式，为其他对象提供一种代理以控制对这个对象的访问。代理对象在客户端和目标对象之间起到中介的作用。

### 核心角色
- **抽象主题（Subject）**: 定义代理类和真实主题的公共接口
- **真实主题（RealSubject）**: 定义代理所代表的真实对象
- **代理（Proxy）**: 保存对真实主题的引用，提供与真实主题相同的接口

### 应用场景
1. **方法增强** - 在不修改原有代码的情况下，增强方法功能（如事务管理、日志记录）
2. **接口代理** - 为接口提供实现（如MyBatis的Mapper接口）
3. **远程代理** - 为远程对象提供本地代表（如RPC框架）
4. **虚拟代理** - 延迟加载重量级对象
5. **保护代理** - 控制对原始对象的访问权限
6. **缓存代理** - 为开销大的运算结果提供缓存

---

## 代理模式的分类

### 1. 静态代理
在编译期就确定代理类，代理类与目标类实现相同接口或继承相同父类。

**优点：**
- 实现简单，易于理解
- 代理对象与目标对象分离，符合开闭原则

**缺点：**
- 每个目标类都需要创建一个代理类，代码冗余
- 接口方法增加时，目标类和代理类都需要修改

### 2. 动态代理
在运行时动态生成代理类。

#### JDK动态代理
- 基于接口实现
- 使用反射机制
- 通过`Proxy.newProxyInstance()`创建代理对象
- 必须实现`InvocationHandler`接口

#### CGLIB动态代理
- 基于继承实现
- 使用字节码技术
- 通过`Enhancer`类创建代理对象
- 必须实现`MethodInterceptor`接口

---

## 后端代理模式实战

### 场景一：方法增强 - 事务管理（静态代理）

#### 1. 定义服务接口
```java
public interface UserService {
    void save();
}
```

#### 2. 实现真实服务
```java
@Slf4j
public class UserServiceImpl implements UserService {
    private UserMapper userMapper;

    public UserServiceImpl(UserMapper userMapper) {
        this.userMapper = userMapper;
    }

    @Override
    public void save() {
        log.info("UserServiceImpl --- save");
        userMapper.save();
    }
}
```

#### 3. 创建静态代理类
```java
@Slf4j
public class UserServiceProxy implements UserService {
    private UserService userService;

    public UserServiceProxy(UserService userService) {
        this.userService = userService;
    }

    @Override
    public void save() {
        ConnectionUtils.Connection conn = ConnectionUtils.getConnection();
        conn.beginTransaction();  // 事务开启
        userService.save();       // 执行业务逻辑
        conn.commit();            // 事务提交
    }
}
```

**关键点：**
- 代理类在方法执行前后添加事务控制逻辑
- 这就是Spring AOP实现事务管理的原理

---

### 场景二：接口代理 - MyBatis Mapper实现

#### 1. 定义Mapper接口和注解
```java
// 自定义Insert注解
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Insert {
    String value() default "";
}

// Mapper接口
public interface UserMapper {
    @Insert(value = "insert into user")
    void save();
}
```

#### 2. JDK动态代理实现
```java
public class MapperJDKInvocationHandler implements InvocationHandler {
    private static final Logger log = LoggerFactory.getLogger(MapperJDKInvocationHandler.class);

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        ConnectionUtils.Connection conn = ConnectionUtils.getConnection();
        // 解析注解获取SQL语句
        Object insertSql = AnnotationUtil.getAnnotationValue(method, Insert.class);
        log.info("执行语句：{}", insertSql);
        // 实际场景：执行SQL、处理参数、返回结果
        return null;
    }
}

// 使用方式
UserMapper mapper = (UserMapper) Proxy.newProxyInstance(
    UserMapper.class.getClassLoader(),
    new Class[]{UserMapper.class},
    new MapperJDKInvocationHandler()
);
mapper.save();
```

#### 3. CGLIB动态代理实现
```java
@Slf4j
public class MapperCglibInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        ConnectionUtils.Connection conn = ConnectionUtils.getConnection();
        Object insertSql = AnnotationUtil.getAnnotationValue(method, Insert.class);
        log.info("执行语句：{}", insertSql);
        return null;
    }
}

// 使用方式
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(UserMapper.class);
enhancer.setCallback(new MapperCglibInterceptor());
UserMapper mapper = (UserMapper) enhancer.create();
mapper.save();
```

**MyBatis原理分析：**
1. 扫描Mapper接口
2. 使用动态代理为接口创建实现类
3. 拦截方法调用，解析注解或XML配置
4. 拼接SQL、执行数据库操作、封装结果

---

### 场景三：虚拟代理 - 延迟加载

```java
public class ConnectionUtils {
    private static ThreadLocal<Connection> threadLocal = new ThreadLocal<>();

    // 延迟加载 - 先创建代理对象，使用时才创建真实对象
    public static Connection getConnection() {
        Connection connection = threadLocal.get();
        if (ObjectUtil.isNotNull(connection)) {
            return connection;
        }
        ConnectionProxy connectionProxy = new ConnectionProxy();
        threadLocal.set(connectionProxy);
        return connectionProxy;
    }

    // 连接接口
    public interface Connection {
        void beginTransaction();
        void commit();
        void rollback();
    }

    // 真实连接（重量级对象）
    @Slf4j
    static class MyConnection implements Connection {
        @Override
        public void beginTransaction() {
            log.info("beginTransaction --- 开启事务");
        }

        @Override
        public void commit() {
            log.info("commit --- 提交事务");
        }

        @Override
        public void rollback() {
            log.info("rollback --- 回滚事务");
        }
    }

    // 连接代理（轻量级对象）
    @Slf4j
    static class ConnectionProxy implements Connection {
        private Connection connection;

        private Connection getConnection() {
            if (ObjectUtil.isEmpty(connection)) {
                log.info("ConnectionProxy --- 进行懒加载");
                connection = new MyConnection();
            }
            return connection;
        }

        @Override
        public void beginTransaction() {
            Connection conn = getConnection();  // 真正使用时才创建
            log.info("ConnectionProxy --- 开启事务");
        }

        @Override
        public void commit() {
            Connection conn = getConnection();
            log.info("ConnectionProxy --- 提交事务");
        }

        @Override
        public void rollback() {
            Connection conn = getConnection();
            log.info("ConnectionProxy --- 回滚事务");
        }
    }
}
```

**延迟加载的优势：**
- 减少系统资源占用
- 提升程序启动速度
- 按需分配资源

---

### 场景四：远程代理 - RPC框架原理

**为什么RPC框架可以像调用本地方法一样调用远程服务？**

```java
// 定义远程服务接口
public interface RemoteUserService {
    User getUserById(Long id);
}

// RPC动态代理实现
public class RPCInvocationHandler implements InvocationHandler {
    private String serverAddress;

    public RPCInvocationHandler(String serverAddress) {
        this.serverAddress = serverAddress;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 1. 封装请求信息
        RPCRequest request = new RPCRequest();
        request.setClassName(method.getDeclaringClass().getName());
        request.setMethodName(method.getName());
        request.setParameterTypes(method.getParameterTypes());
        request.setParameters(args);

        // 2. 发送网络请求
        RPCResponse response = sendRequest(serverAddress, request);

        // 3. 返回结果
        return response.getResult();
    }

    private RPCResponse sendRequest(String address, RPCRequest request) {
        // 网络通信逻辑（HTTP、Socket、Netty等）
        // ...
        return null;
    }
}

// 使用方式
RemoteUserService remoteService = (RemoteUserService) Proxy.newProxyInstance(
    RemoteUserService.class.getClassLoader(),
    new Class[]{RemoteUserService.class},
    new RPCInvocationHandler("http://remote-server:8080")
);
User user = remoteService.getUserById(1L);  // 像调用本地方法一样
```

**RPC框架代理的核心功能：**
1. 序列化请求参数
2. 网络传输
3. 反序列化响应结果
4. 异常处理
5. 负载均衡（多个服务地址时）

---

## 前端代理模式应用

### 场景一：ES6 Proxy - 数据拦截与响应式

#### 1. 数据验证代理
```javascript
// 用户对象验证
const userValidator = {
  set(target, property, value) {
    switch(property) {
      case 'age':
        if (!Number.isInteger(value)) {
          throw new TypeError('Age must be an integer');
        }
        if (value < 0 || value > 150) {
          throw new RangeError('Age must be between 0 and 150');
        }
        break;
      case 'email':
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(value)) {
          throw new TypeError('Invalid email format');
        }
        break;
    }
    target[property] = value;
    return true;
  }
};

// 使用代理
const user = new Proxy({}, userValidator);
user.name = 'John';
user.age = 25;       // 正常
user.email = 'john@example.com';  // 正常
// user.age = -5;    // 抛出 RangeError
// user.email = 'invalid';  // 抛出 TypeError
```

#### 2. Vue3响应式原理实现
```javascript
// 简化版Vue3响应式系统
const targetMap = new WeakMap();
let activeEffect = null;

// 依赖收集
function track(target, key) {
  if (!activeEffect) return;

  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }

  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, (dep = new Set()));
  }
  dep.add(activeEffect);
}

// 触发更新
function trigger(target, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;

  const dep = depsMap.get(key);
  if (dep) {
    dep.forEach(effect => effect());
  }
}

// 创建响应式对象
function reactive(target) {
  return new Proxy(target, {
    get(target, key, receiver) {
      const result = Reflect.get(target, key, receiver);
      track(target, key);  // 收集依赖
      return result;
    },
    set(target, key, value, receiver) {
      const result = Reflect.set(target, key, value, receiver);
      trigger(target, key);  // 触发更新
      return result;
    }
  });
}

// 副作用函数
function effect(fn) {
  activeEffect = fn;
  fn();
  activeEffect = null;
}

// 使用示例
const state = reactive({
  count: 0,
  message: 'Hello'
});

effect(() => {
  console.log('Count changed:', state.count);
});

state.count++;  // 输出: Count changed: 1
state.count++;  // 输出: Count changed: 2
```

**Vue3 Proxy vs Vue2 Object.defineProperty：**
- Proxy可以监听数组变化
- Proxy可以监听对象属性的添加和删除
- Proxy性能更好（懒代理）
- Proxy支持更多拦截操作

---

### 场景二：图片懒加载（虚拟代理）

```javascript
// 图片懒加载代理类
class ImageProxy {
  constructor() {
    this.realImage = null;
    this.loadingImage = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiPjxyZWN0IHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgZmlsbD0iI2VlZSIvPjwvc3ZnPg==';
  }

  createImage(imgElement, realSrc) {
    // 先显示占位图
    imgElement.src = this.loadingImage;

    // 使用IntersectionObserver监听元素是否进入视口
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          // 进入视口，加载真实图片
          this.loadRealImage(imgElement, realSrc);
          observer.unobserve(imgElement);
        }
      });
    });

    observer.observe(imgElement);
  }

  loadRealImage(imgElement, src) {
    const img = new Image();
    img.onload = () => {
      imgElement.src = src;
      imgElement.classList.add('loaded');
    };
    img.onerror = () => {
      imgElement.src = 'error-image.png';
    };
    img.src = src;
  }
}

// 使用示例
const imageProxy = new ImageProxy();
const images = document.querySelectorAll('img[data-src]');

images.forEach(img => {
  const realSrc = img.getAttribute('data-src');
  imageProxy.createImage(img, realSrc);
});
```

```html
<!-- HTML使用 -->
<img data-src="https://example.com/large-image1.jpg" alt="Image 1">
<img data-src="https://example.com/large-image2.jpg" alt="Image 2">

<style>
  img {
    transition: opacity 0.3s;
    opacity: 0.5;
  }
  img.loaded {
    opacity: 1;
  }
</style>
```

---

### 场景三：API请求缓存代理

```javascript
// API缓存代理
class APIProxy {
  constructor() {
    this.cache = new Map();
    this.pendingRequests = new Map();
  }

  async request(url, options = {}) {
    const cacheKey = this.getCacheKey(url, options);

    // 1. 检查缓存
    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey);
      if (this.isValid(cached)) {
        console.log('From cache:', url);
        return cached.data;
      }
    }

    // 2. 检查是否有正在进行的相同请求（防止重复请求）
    if (this.pendingRequests.has(cacheKey)) {
      console.log('Waiting for pending request:', url);
      return this.pendingRequests.get(cacheKey);
    }

    // 3. 发起真实请求
    const requestPromise = this.fetchData(url, options)
      .then(data => {
        // 缓存结果
        this.cache.set(cacheKey, {
          data,
          timestamp: Date.now(),
          ttl: options.cacheTTL || 60000  // 默认缓存60秒
        });
        this.pendingRequests.delete(cacheKey);
        return data;
      })
      .catch(error => {
        this.pendingRequests.delete(cacheKey);
        throw error;
      });

    this.pendingRequests.set(cacheKey, requestPromise);
    return requestPromise;
  }

  async fetchData(url, options) {
    console.log('Fetching from API:', url);
    const response = await fetch(url, options);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  }

  getCacheKey(url, options) {
    return `${url}_${JSON.stringify(options)}`;
  }

  isValid(cached) {
    return Date.now() - cached.timestamp < cached.ttl;
  }

  clearCache() {
    this.cache.clear();
  }
}

// 使用示例
const apiProxy = new APIProxy();

async function getUserData() {
  try {
    // 第一次请求 - 从API获取
    const data1 = await apiProxy.request('/api/users/1');
    console.log(data1);

    // 第二次请求 - 从缓存获取
    const data2 = await apiProxy.request('/api/users/1');
    console.log(data2);

    // 自定义缓存时间
    const data3 = await apiProxy.request('/api/users/2', {
      cacheTTL: 120000  // 缓存2分钟
    });
  } catch (error) {
    console.error('Request failed:', error);
  }
}
```

---

### 场景四：访问控制代理（权限管理）

```javascript
// 权限管理代理
class PermissionProxy {
  constructor(target, currentUser) {
    this.target = target;
    this.currentUser = currentUser;

    return new Proxy(target, {
      get: (target, property) => {
        // 检查是否有读权限
        if (!this.hasReadPermission(property)) {
          throw new Error(`Access denied: Cannot read property '${property}'`);
        }
        return target[property];
      },
      set: (target, property, value) => {
        // 检查是否有写权限
        if (!this.hasWritePermission(property)) {
          throw new Error(`Access denied: Cannot write property '${property}'`);
        }
        target[property] = value;
        this.logAccess('write', property, value);
        return true;
      },
      deleteProperty: (target, property) => {
        if (!this.hasDeletePermission(property)) {
          throw new Error(`Access denied: Cannot delete property '${property}'`);
        }
        delete target[property];
        this.logAccess('delete', property);
        return true;
      }
    });
  }

  hasReadPermission(property) {
    const permissions = {
      admin: ['id', 'name', 'email', 'salary', 'ssn'],
      manager: ['id', 'name', 'email', 'salary'],
      employee: ['id', 'name', 'email']
    };
    return permissions[this.currentUser.role]?.includes(property);
  }

  hasWritePermission(property) {
    const permissions = {
      admin: ['name', 'email', 'salary', 'ssn'],
      manager: ['name', 'email'],
      employee: ['email']
    };
    return permissions[this.currentUser.role]?.includes(property);
  }

  hasDeletePermission(property) {
    return this.currentUser.role === 'admin';
  }

  logAccess(action, property, value) {
    console.log(`[${new Date().toISOString()}] User ${this.currentUser.name} ${action} property '${property}'${value ? ': ' + value : ''}`);
  }
}

// 使用示例
const employeeData = {
  id: 1001,
  name: 'John Doe',
  email: 'john@company.com',
  salary: 50000,
  ssn: '123-45-6789'
};

// 管理员访问
const adminUser = { name: 'Admin', role: 'admin' };
const adminProxy = new PermissionProxy(employeeData, adminUser);
console.log(adminProxy.salary);  // 正常访问
adminProxy.salary = 55000;       // 正常修改

// 普通员工访问
const normalUser = { name: 'Jane', role: 'employee' };
const employeeProxy = new PermissionProxy(employeeData, normalUser);
console.log(employeeProxy.name);   // 正常访问
// console.log(employeeProxy.salary);  // 抛出错误：Access denied
// employeeProxy.name = 'New Name';    // 抛出错误：Access denied
```

---

### 场景五：前端状态管理（类Redux实现）

```javascript
// 简化版Redux的Proxy实现
class Store {
  constructor(reducer, initialState) {
    this.reducer = reducer;
    this.listeners = new Set();

    // 使用Proxy创建响应式状态
    this.state = new Proxy(initialState, {
      set: (target, property, value) => {
        target[property] = value;
        this.notify();
        return true;
      }
    });
  }

  getState() {
    return this.state;
  }

  dispatch(action) {
    console.log('Dispatching action:', action);
    const newState = this.reducer(this.state, action);
    Object.assign(this.state, newState);
  }

  subscribe(listener) {
    this.listeners.add(listener);
    // 返回取消订阅函数
    return () => this.listeners.delete(listener);
  }

  notify() {
    this.listeners.forEach(listener => listener(this.state));
  }
}

// Reducer函数
function counterReducer(state, action) {
  switch(action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    case 'ADD_TODO':
      return {
        ...state,
        todos: [...state.todos, action.payload]
      };
    default:
      return state;
  }
}

// 使用示例
const store = new Store(counterReducer, {
  count: 0,
  todos: []
});

// 订阅状态变化
const unsubscribe = store.subscribe((state) => {
  console.log('State changed:', state);
  // 更新UI
  document.getElementById('count').textContent = state.count;
});

// 派发动作
store.dispatch({ type: 'INCREMENT' });
store.dispatch({ type: 'INCREMENT' });
store.dispatch({ type: 'ADD_TODO', payload: { id: 1, text: 'Learn Proxy' } });

// 取消订阅
// unsubscribe();
```

---

### 场景六：防抖节流代理

```javascript
// 防抖节流代理工具类
class ThrottleDebounceProxy {
  // 防抖：延迟执行，只执行最后一次
  static debounce(func, delay = 300) {
    let timer = null;

    return new Proxy(func, {
      apply(target, thisArg, args) {
        clearTimeout(timer);
        timer = setTimeout(() => {
          target.apply(thisArg, args);
        }, delay);
      }
    });
  }

  // 节流：固定时间间隔执行
  static throttle(func, interval = 300) {
    let lastTime = 0;

    return new Proxy(func, {
      apply(target, thisArg, args) {
        const now = Date.now();
        if (now - lastTime >= interval) {
          lastTime = now;
          target.apply(thisArg, args);
        }
      }
    });
  }
}

// 使用示例
// 搜索输入防抖
const searchInput = document.getElementById('search');
const search = ThrottleDebounceProxy.debounce((keyword) => {
  console.log('Searching for:', keyword);
  // 发起API请求
}, 500);

searchInput.addEventListener('input', (e) => {
  search(e.target.value);
});

// 滚动事件节流
const handleScroll = ThrottleDebounceProxy.throttle(() => {
  console.log('Scroll position:', window.scrollY);
  // 处理滚动逻辑
}, 200);

window.addEventListener('scroll', handleScroll);
```

---

### 场景七：前端路由守卫（保护代理）

```javascript
// 路由守卫代理
class RouteGuard {
  constructor(router, authService) {
    this.router = router;
    this.authService = authService;

    return new Proxy(router, {
      get: (target, property) => {
        if (property === 'navigate') {
          return new Proxy(target[property], {
            apply: async (fn, thisArg, args) => {
              const [route] = args;

              // 检查路由权限
              if (this.requiresAuth(route)) {
                const isAuthenticated = await this.authService.checkAuth();

                if (!isAuthenticated) {
                  console.log('Not authenticated, redirecting to login');
                  return target.navigate.call(thisArg, '/login');
                }

                const hasPermission = await this.authService.checkPermission(route);
                if (!hasPermission) {
                  console.log('No permission, redirecting to 403');
                  return target.navigate.call(thisArg, '/forbidden');
                }
              }

              // 执行导航
              return fn.apply(thisArg, args);
            }
          });
        }
        return target[property];
      }
    });
  }

  requiresAuth(route) {
    const publicRoutes = ['/', '/login', '/register'];
    return !publicRoutes.includes(route);
  }
}

// 简单的路由器实现
class Router {
  navigate(route) {
    console.log(`Navigating to ${route}`);
    window.history.pushState({}, '', route);
    // 渲染对应组件
  }
}

// 认证服务
class AuthService {
  async checkAuth() {
    // 检查token是否有效
    const token = localStorage.getItem('token');
    return !!token;
  }

  async checkPermission(route) {
    // 检查用户是否有权限访问该路由
    const userRole = localStorage.getItem('role');
    const routePermissions = {
      '/admin': ['admin'],
      '/dashboard': ['admin', 'user'],
      '/profile': ['admin', 'user']
    };
    return routePermissions[route]?.includes(userRole);
  }
}

// 使用示例
const router = new Router();
const authService = new AuthService();
const guardedRouter = new RouteGuard(router, authService);

// 尝试导航
guardedRouter.navigate('/dashboard');  // 会检查权限
guardedRouter.navigate('/admin');      // 会检查权限
```

---

## 总结与对比

### 静态代理 vs 动态代理

| 特性 | 静态代理 | JDK动态代理 | CGLIB动态代理 |
|-----|---------|------------|--------------|
| 实现方式 | 手动编写代理类 | 反射+接口 | 字节码+继承 |
| 是否需要接口 | 是 | 是 | 否 |
| 灵活性 | 低 | 高 | 高 |
| 性能 | 高 | 中 | 中（首次创建慢） |
| 使用场景 | 代理类少、逻辑简单 | 基于接口的代理 | 无接口的类代理 |

### 前后端代理模式对比

| 维度 | 后端（Java） | 前端（JavaScript） |
|-----|------------|------------------|
| 主要实现 | JDK Proxy、CGLIB、静态代理 | ES6 Proxy、函数包装 |
| 常见场景 | AOP、事务、权限、RPC | 响应式、懒加载、缓存、验证 |
| 性能考虑 | 反射开销、字节码生成 | V8优化、浏览器兼容性 |
| 典型框架 | Spring AOP、MyBatis | Vue3、Mobx、Immer |

### 代理模式的优缺点

**优点：**
1. 职责清晰 - 真实主题只关注业务逻辑
2. 扩展性好 - 可以在不修改真实主题的情况下扩展功能
3. 保护真实对象 - 控制对真实对象的访问
4. 延迟加载 - 优化资源使用

**缺点：**
1. 增加复杂性 - 多了一层代理
2. 性能开销 - 额外的方法调用
3. 静态代理代码冗余 - 每个类都需要代理类

### 实际应用建议

**后端：**
- Spring事务管理：优先使用注解式AOP（@Transactional）
- MyBatis Mapper：理解原理，正确使用接口
- RPC调用：选择成熟框架（Dubbo、gRPC）
- 延迟加载：考虑性能和复杂度平衡

**前端：**
- 框架响应式：Vue3 Proxy、React Hooks
- 性能优化：图片懒加载、路由懒加载
- 数据管理：API缓存、请求去重
- 用户体验：防抖节流、加载状态

### 最佳实践

1. **选择合适的代理类型**
   - 有接口 → JDK动态代理
   - 无接口 → CGLIB动态代理
   - 逻辑简单 → 静态代理

2. **注意性能影响**
   - 避免过度代理
   - 合理使用缓存
   - 减少反射调用

3. **保持代码可维护性**
   - 代理逻辑单一职责
   - 添加必要的日志
   - 编写单元测试

4. **前端特别注意**
   - Proxy兼容性（IE不支持）
   - 避免循环引用
   - 合理使用WeakMap避免内存泄漏

---

## 参考资料

**后端：**
- Spring AOP官方文档
- MyBatis源码分析
- 《设计模式：可复用面向对象软件的基础》

**前端：**
- MDN - Proxy
- Vue3源码分析
- JavaScript设计模式与开发实践

---

## 课后练习

### 练习1：实现一个日志代理
为任意类添加方法执行日志（方法名、参数、返回值、执行时间）

### 练习2：实现前端表单验证代理
使用Proxy实现一个表单数据验证器，支持多种验证规则

### 练习3：实现接口Mock代理
创建一个代理类，在开发环境返回Mock数据，生产环境调用真实API

### 练习4：实现简单的响应式系统
参考Vue3 Proxy实现，创建一个简单的响应式状态管理库
